// options.yy.cpp generated by reflex 2.0.1 from options.l

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_dotall              true
#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_freespace           true
#define REFLEX_OPTION_header_file         "options.yy.h"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               OptionsLexer
#define REFLEX_OPTION_noline              true
#define REFLEX_OPTION_outfile             "options.yy.cpp"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


	#include "z80asm_usage.h"
	#include "legacy.h"
	#include <iostream>


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class OptionsLexer : public reflex::AbstractLexer<reflex::Matcher> {

	protected:
		bool verbose;

 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  OptionsLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  virtual int lex();
  int lex(
      const reflex::Input& input,
      std::ostream        *os = NULL)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// z80asm restart
// Copyright (C) Paulo Custodio, 2011-2020
// License: The Artistic License 2.0, http://www.perlfoundation.org/artistic_license_2_0
//-----------------------------------------------------------------------------


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

extern void reflex_code_INITIAL(reflex::Matcher&);

int OptionsLexer::lex()
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return int();
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 23: -v\z|--verbose\z :
{ verbose = true; return true; }

            break;
          case 2: // rule at line 26: -h\z|--help\z :
{ using namespace std;
				  cout << copyrightmsg << endl << endl
					   << z80asm_usage;
				  exit(EXIT_SUCCESS);
				  return true; 	// not reached
				}

            break;
          case 3: // rule at line 33: [\x00-\xff] :
{ return false; }

            break;
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == '-') goto S2;
  if (0 <= c1) goto S7;
  return m.FSM_HALT(c1);

S2:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if (c1 == 'v') goto S9;
  if (c1 == 'h') goto S14;
  if (c1 == '-') goto S11;
  return m.FSM_HALT(c1);

S7:
  m.FSM_TAKE(3);
  return m.FSM_HALT();

S9:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(1, c1);
  }
  return m.FSM_HALT(c1);

S11:
  c1 = m.FSM_CHAR();
  if (c1 == 'v') goto S18;
  if (c1 == 'h') goto S20;
  return m.FSM_HALT(c1);

S14:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(2, c1);
  }
  return m.FSM_HALT(c1);

S16:
  m.FSM_TAKE(1);
  return m.FSM_HALT();

S18:
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S24;
  return m.FSM_HALT(c1);

S20:
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S26;
  return m.FSM_HALT(c1);

S22:
  m.FSM_TAKE(2);
  return m.FSM_HALT();

S24:
  c1 = m.FSM_CHAR();
  if (c1 == 'r') goto S28;
  return m.FSM_HALT(c1);

S26:
  c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S30;
  return m.FSM_HALT(c1);

S28:
  c1 = m.FSM_CHAR();
  if (c1 == 'b') goto S32;
  return m.FSM_HALT(c1);

S30:
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S34;
  return m.FSM_HALT(c1);

S32:
  c1 = m.FSM_CHAR();
  if (c1 == 'o') goto S36;
  return m.FSM_HALT(c1);

S34:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(2, c1);
  }
  return m.FSM_HALT(c1);

S36:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S38;
  return m.FSM_HALT(c1);

S38:
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S40;
  return m.FSM_HALT(c1);

S40:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(1, c1);
  }
  return m.FSM_HALT(c1);
}

